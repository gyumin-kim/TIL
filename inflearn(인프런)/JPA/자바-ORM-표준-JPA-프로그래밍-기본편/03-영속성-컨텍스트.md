# 영속성 컨텍스트

- JPA에서 가장 중요한 2가지
  - 객체와 관계형 데이터베이스 매핑하기 (Object Relational Mapping)
  - **영속성 컨텍스트** (=내부 동작방식)

EntityManagerFactory가 고객의 요청이 들어올때마다 EntityManager를 생성한다.  
EntityManager는 connection을 통해 DB를 사용

- 영속성 컨텍스트
  - JPA를 이해하는 데 가장 중요한 용어
  - **Entity를 영구 저장하는 환경**
  - `EntityManager.persist(entity);`

영속성 컨텍스트를 통해서 엔티티를 영속화한다(영속성 컨텍스트에 저장한다).

- 영속성 컨텍스트는 논리적인 개념
- 눈에 보이지 않는다.
- EntityManager를 통해서 영속성 컨텍스트에 접근(EntityManager 안에 영속성 컨텍스트가 존재한다)

엔티티 매니저와 영속성 컨텍스트가 1:1
![image](https://user-images.githubusercontent.com/26949964/71476102-c0660080-2826-11ea-8a5d-7557219fc9d4.png)

- 엔티티의 생명주기
  - 비영속(new/transient)
    - 최초에 entity를 생성한 상태
    - 영속성 컨텍스트와 전혀 관계가 없는 새로운 상태
  - 영속
    - persist한 상태
  - 준영속
  - 삭제

- 비영속  
  entity 객체를 생성만 하고 영속성 컨텍스트에 넣지 않은 상태. JPA와 관계가 없는 상태
  ```java
  Member member = new Member();
  member.setId("member1");
  member.setUsername("회원1");
  ```

- 영속
  ```java
  Member member = new Member();
  member.setId("member1");
  member.setUsername("회원1");

  EntityManager em = emf.createEntityManager();
  em.getTransaction().begin();

  em.persist(member); // 객체를 저장한 상태(영속)
  ```
  영속성 컨텍스트 안에 entity 객체가 들어가면서 영속 상태가 된다.
  영속 상태가 된다고 해서 DB에 쿼리가 날라가는 것이 아니라, commit해야 한다.

- 준영속  
  ```java
  em.detach(member); // entity 객체를 영속성 컨텍스트에서 분리 (준영속 상태)
  em.remove(member); // entity 객체를 삭제한 상태 (삭제)
  ```

- 영속성 컨텍스트의 이점
  - 애플리케이션과 DB 사이에 뭔가 있다.
  - 엔티티 조회, 1차 캐시
    ![image](https://user-images.githubusercontent.com/26949964/71479006-ef37a300-2835-11ea-9fa6-19b3a49cf08f.png)
    - 1차 캐시는 영속성 컨텍스트 안에 존재
    - `em.persist()`를 하면 1차 캐시 안에 저장된다(DB가 아니라)
    - 조회할 때 1차 캐시를 먼저 살펴보고, 있으면 DB까지 가지 않는다.
    - 1차 캐시에 없다면, DB에서 조회해서 1차 캐시에 저장한 다음, entity 객체를 반환한다.
    - (EntityManager는 트랜잭션 단위이므로, 하나의 비즈니스 로직을 다 수행하고 나면 지워지고, 1차 캐시도 다 날아간다.)
  - 영속 엔티티의 동일성 보장
    - 마치 Collection에서 같은 element를 꺼내오면 동일성이 보장되는 것과 같다.
  - 엔티티 등록: 트랜잭션을 지원하는 쓰기 지연
    ```java
    EntityManager em = emf.createEntityManager();
    EntityTransaction transaction = em.getTransaction();
    transaction.begin();

    em.persist(memberA);
    em.persist(memberB);
    // 여기까지 INSERT SQL을 데이터베이스에 보내지 않는다.

    // commit하는 순간 데이터베이스에 INSERT SQL을 보낸다.
    transaction.commit();
    ```
    - 버퍼링을 모아서 한 번에 write할 수 있으므로 성능의 이점을 얻을 수 있다.
  - 엔티티 수정: 변경 감지
    ```java
    EntityManager em = emf.createEntityManager();
    EntityTransaction transaction = em.getTransaction();
    transaction.begin();

    Member memberA = em.find(Member.class, "memberA");

    memberA.setUsername("hi");
    memberA.setAge(10);

    // em.update(member); -> 이런 코드가 없어도 된다!

    transaction.commit();
    ```
    ![image](https://user-images.githubusercontent.com/26949964/71479643-974e6b80-2838-11ea-9eee-d07d860b6a06.png)
    - 영속성 컨텍스트로 객체를 읽어온 최초의 시점을 스냅샷으로 떠 놓는다.
  - 엔티티 삭제