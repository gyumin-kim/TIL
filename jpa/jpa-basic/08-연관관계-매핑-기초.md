# 연관관계 매핑 기초

좀 더 객체지향적으로 어떻게 설계하는지.
객체와 관계형 DB와의 패러다임의 충돌 문제를 해결

- **객체의 참조와 테이블의 외래 키를 매핑**
- 용어
  - 방향(Direction): 단방향, 양방향
  - 다중성(Multiplicity): 다대일(N:1), 일대다(1:N), 일대일(1:1), 다대다(N:N)
  - 연관관계의 주인(Owner): 객체 양방향 연관관계는 관리 주인이 필요

### 연관관계가 필요한 이유
- 객체를 테이블에 맞추어 데이터 중심으로 모델링 하면, 협력 관계를 만들 수 없다.
  - **테이블은 외래키로 조인을 사용**해서 연관된 테이블을 찾는다.
  - **객체는 참조를 사용**해서 연관된 객체를 찾는다.
  - 테이블과 객체 사이에는 이런 큰 간격이 있다.

---
## 단방향 연관관계
- 객체지향스러운 모델링
![image](https://user-images.githubusercontent.com/26949964/73118450-9e7fab00-3f97-11ea-8345-4c88a03cecbc.png)
- Member가 Team의 참조값을 그대로 갖고 있다.
- `@JoinColumn`
  - **외래 키를 매핑할 때** 사용한다(조인하는 column이 무엇인가).
  - N(다)쪽 entity에서 가지는 레퍼런스와, 테이블의 외래 키와 매핑한다. 위 그림에서는 Member entity가 가지는 team 레퍼런스와 MEMBER 테이블의 TEAM_ID라는 외래키를 매핑하는 것이다.

---
## 양방향 연관관계와 연관관계의 주인 - 기본
![image](https://user-images.githubusercontent.com/26949964/73175125-ce23e400-414c-11ea-92c8-b7f84b6196c4.png)
테이블 연관관계는 외래키 하나로 양방향(사실 방향이라는 개념이 없는 것, 외래키 하나면 됨)
객체는 가급적이면 단방향이 좋다. 양방향은 신경쓸 게 많다.
- 객체와 테이블이 관계를 맺는 차이
  - 객체 연관관계 = 2개
    - 회원 → 팀 연관관계 1개 (단뱡향)
    - 팀 → 회원 연관관계 1개 (단뱡향)
  - 테이블 연관관계 = 1개
    - 회원 ↔︎ 팀 연관관계 1개 (양방향)
    - 사실은 방향이라는 개념 자체가 없는 것.
- 객체의 양방향 연관관계
  - 객체의 양방향 관계는 사실 ~~양방향 관계~~가 아니라, **서로 다른 2개의 단방향 관계**다.
  - 객체를 양방향으로 참조하려면 **단방향 연관관계를 2개** 만들어야 한다.
- 테이블의 양방향 연관관계
  - **외래 키 하나**로 두 테이블의 연관관계를 관리
- **mappedBy**
  ![image](https://user-images.githubusercontent.com/26949964/73176385-a3875a80-414f-11ea-9961-5ec2376d4d4d.png)
  - 실제 DB의 `MEMBER` 테이블의 `TEAM_ID` 값을 어떤 기준으로 update할 것인지가 정해져야만 한다.
    - 결국은 **두 객체 중 하나로 외래 키를 관리**해야 한다.
    - 이를 정하는 것이 `mappedBy` 속성이다. 즉 Member 객체의 team과 Team 객체의 members 중 어느 것으로 외래키를 관리할 것인지를 정한다. 이것을 **연관관계의 주인**(Owner)이라고 한다.
- 연관관계의 주인
  - 객체의 두 관계 중 하나를 연관관계의 주인으로 지정
  - 연관관계의 **주인만이 외래 키를 관리(등록, 수정)**
  - **주인이 아닌 쪽은 읽기만** 가능
  - 주인은 mappedBy 속성을 사용하지 않는다.
  - 주인이 아니면 mappedBy 속성으로 주인을 지정한다.
  - **비즈니스 로직과는 전혀 무관**하며, **실제 DB에 어떤 식으로 update가 수행되도록 할 것인지**를 정하는 것이다.
- 누구를 주인으로?
  - **외래 키가 있는 쪽(N)을 주인으로 정해라**. 그렇게 하는 것이 편하다.
  ![image](https://user-images.githubusercontent.com/26949964/73177240-dd596080-4151-11ea-92d5-6c2214943308.png)
  - 위 그림에서는 Member.team이 연관관계의 주인이다.
  - 만약 반대로 Team.members를 주인으로 했다면, Team의 필드(members)를 수정했는데 DB에는 MEMBER에 update 쿼리가 나가게 되어 헷갈리기가 쉽다.
  - 결국 `@~~~ToOne`쪽(ManyToOne 등)이 주인이 되도록 하면 된다.

---
## 양방향 연관관계와 연관관계의 주인 - 주의점, 정리
- 양방향 매핑 시 가장 많이 하는 실수
```java
Team team = new Team();
team.setName("TeamA");
em.persist(team);

Member member = new Member();
member.setName("member1");

// 역방향(주인이 아닌 방향)에만 연관관계를 설정하고 있다. (주인 쪽에는 설정하지 않음)
team.getMembers().add(member);

em.persist(member);
```
  - 위 코드를 실행해도 `team.getMembers().add(member)` 부분에서 의도한 쓰기(insert or update) 쿼리는 실질적으로 실행되지 않는다. N(다)쪽인 Member가 양방향 연관관계의 주인인데, 그 반대 방향인 Team에 연관관계를 설정했기 때문이다.
  - | ID    | USERNAME      | TEAM_ID  |
    | ----- |:-------------:| --------:|
    | 1     | member1       | null     |
- 순수한 객체 관계를 고려하면, **항상 양쪽 모두 값을 입력해야 한다**.
  ```java
  Team team = new Team();
  team.setName("TeamA");
  em.persist(team);

  Member member = new Member();
  member.setName("member1");

  // 연관관계의 주인에 값 설정
  member.setTeam(team);
  team.getMembers().add(member);

  em.persist(member);
  ```
- 양쪽에 값을 설정하기 위해, **연관관계 편의 메서드**를 생성하면 좋다.
  - 1쪽이나 N쪽 어디에 생성해도 상관없다.
- 양방향 매핑 시 무한 루프를 조심하자.
  - ex) toString(), lombok, JSON 생성 라이브러리
  - Entity 객체를 Controller에서 바로 응답 데이터를 만드는 데 사용하면 문제가 될 수 있다.

### 양방향 매핑 정리
- **단방향 매핑만으로도 이미 테이블과 객체의 연관관계 매핑은 완료**된 것.
  - 처음에는 일단 단방향 매핑으로 설계를 끝내야 한다.
- 단, 단방향을 양방향 매핑으로 만들면 반대 방향으로 조회(객체 그래프 탐색) 기능이 추가된 것 뿐.
- JPQL에서 역방향으로 탐색할 일이 많음.
- 단방향 매핑을 잘 해두고, 양방향은 필요할 때 추가해도 됨
  - 어차피 테이블에 영향을 주지 않음

### 연관관계의 주인을 정하는 기준
- 비즈니스 로직을 기준으로 연관관계의 주인을 선택하면 안된다.
- **연관관계의 주인은 외래 키의 위치를 기준으로** 정해야 한다.